# -*- coding: utf-8 -*-
"""app_v0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pFp92L4ZqC4YGgNpqBCoQHgZHZ-mpxt5
"""

# !pip install dash
# # !pip install dash==1.19.0
# !pip install jupyter_dash
# !pip install --upgrade plotly
# !pip install dash --upgrade
# !pip install dash_bootstrap_components

"""<!--  -->"""

# Import required libraries
import pandas as pd
import dash
from dash import dcc
from dash import html
from dash.dependencies import Input, Output, State
from jupyter_dash import JupyterDash
import plotly.graph_objects as go
import plotly.express as px
from dash import no_update
import dash_bootstrap_components as dbc


#  import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
# Allows us to test parameters of classification algorithms and find the best one
from sklearn.model_selection import GridSearchCV
# Logistic Regression classification algorithm
from sklearn.linear_model import LogisticRegression
# Support Vector Machine classification algorithm
from sklearn.linear_model import LinearRegression

from sklearn import preprocessing
from sklearn.preprocessing import LabelEncoder
import tensorflow as tf

from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
import plotly.figure_factory as ff

import plotly.graph_objects as go
from sklearn.tree import DecisionTreeClassifier


import pandas as pd
import zipfile
import requests
from io import BytesIO

tcouleur = 'plotly_dark'
bcouleur = 'navy'
fcouleur = 'white'
fsize = 20


def plot_history_dash(df,feat):
    fig_cm = px.histogram(data_frame= df,x=feat,opacity= 0.7)

    fig_cm.update_layout(
       barmode='overlay',
        # paper_bgcolor=bcouleur,  # Set the background color here
        font=dict(color=fcouleur,size=fsize),  # Set the font color to here
        title_x=0.5,
        title_y=0.9,
        template=tcouleur
    )
    return fig_cm

def plot_history_all_dash(df ):
    fig  = px.histogram(data_frame= df,opacity= .7).update_xaxes(categoryorder='total descending')
    fig .update_layout(
       barmode='overlay',
        # paper_bgcolor=bcouleur,  # Set the background color here
        font=dict(color=fcouleur,size=fsize),  # Set the font color to here
        title_x=0.5,
        title_y=0.9,
        template=tcouleur
    )
    fig.update_xaxes(
            title_font = {"size": 14},
            title_standoff = 25)
    return fig

def plot_confusion_matrix_dash(y,y_predict,cmLabel,lab):
    cm = confusion_matrix(y, y_predict)
    if lab == 1:
        fig = ff.create_annotated_heatmap(cm,
                                          x=cmLabel[:cm.shape[1]],
                                          y=cmLabel[:cm.shape[1]],
                                          colorscale='Viridis',showscale=True)
        fig.update_xaxes(
                title_text='Predicted labels',
                title_font = {"size": 18},
                title_standoff = 25,
                side='bottom')
        fig.update_yaxes(
                title_text = 'True labels',
                title_font = {"size": 18},
                title_standoff = 25)
    else:
        annotation_text = [['' for _ in range(cm.shape[1])] for _ in range(cm.shape[0])]
        fig = ff.create_annotated_heatmap(cm,
                                          x=cmLabel[:cm.shape[1]],
                                          y=cmLabel[:cm.shape[1]],
                                          colorscale='Viridis',
                                          annotation_text=annotation_text,
                                          showscale=True)
        fig.update_xaxes(
                title_text='Prediction',
                title_font = {"size": 18},
                title_standoff = 25,
                side='bottom')
        # fig.update_xaxes(  showticklabels=False )
        fig.update_yaxes(
                title_text = 'True Solution',
                title_font = {"size": 18},
                title_standoff = 25,
                showticklabels=False  # Hide the x-axis
                )
    fig.update_layout(
        title='Confusion Matrix',
        font=dict(color=fcouleur,size=fsize),  # Set the font color to here
        template=tcouleur
    )
    fig.update_layout(
        # paper_bgcolor=bcouleur,  # Set the background color here
        font=dict(color=fcouleur,size=fsize),  # Set the font color to here
        title_x=0.5,
        title_y=0.9,
        template=tcouleur
    )
    return fig

def plot_classification_report_dash(y, y_predict,cmLabel,lab):

    report_str = classification_report(y, y_predict,  zero_division=0)
    report_lines = report_str.split('\n')

    # Remove empty lines
    report_lines = [line for line in report_lines if line.strip()]
    data = [line.split() for line in report_lines[1:]]
    colss = ['feature', 'precision',   'recall',  'f1-score',   'support', 'n1one']

    # Convert to a DataFrame
    report_df = pd.DataFrame(data, columns = colss )
    report_df = report_df[report_df.columns[:-1]]
    cm = report_df.iloc[:-3,1:].apply(pd.to_numeric).values
    colss1 = [  'precision',   'recall',  'f1-score',   'support']
    if lab == 1:
        fig_cm = ff.create_annotated_heatmap(cm,
                                             x = colss1,
                                             y = cmLabel[:cm.shape[0]],
                                             colorscale='Viridis' )
        fig_cm.update_yaxes(
                 title_text = 'y',
                title_font = {"size": 18},
                title_standoff = 25,
                showticklabels=False  # Hide the x-axis
                )
    else:
        cmm =  cm[:,:-1]
        annotation_text = [['' for _ in range(cmm.shape[1])] for _ in range(cmm.shape[0])]
        fig_cm = ff.create_annotated_heatmap(cmm,
                                             x = colss1[:-1],
                                             colorscale='Viridis',
                                             showscale=True,
                                             annotation_text=annotation_text )
        fig_cm.update_yaxes(
                 title_text = 'y',
                title_font = {"size": 18},
                # title_standoff = 25,
                showticklabels=False  # Hide the x-axis
                )
    fig_cm.update_layout(
          title='Classification Report',
          # paper_bgcolor=bcouleur,  # Set the background color here
          font=dict(color=fcouleur,size=fsize),  # Set the font color to here
          title_x=0.5,
          title_y=0.9,
          template=tcouleur
      )
    return fig_cm

from sklearn.tree import DecisionTreeClassifier
def ML_DecisionTreeClassifier(X_test, X_train, y_train) :
    clf = DecisionTreeClassifier()
    clf.fit(X_train, y_train)
    return clf.predict(X_test)

from sklearn.linear_model import LogisticRegression
def ML_LogisticRegression(X_test, X_train, y_train) :
    clf = LogisticRegression(solver='lbfgs', max_iter=1000)
    clf.fit(X_train, y_train)
    return clf.predict(X_test)

from sklearn.svm import SVC
def ML_SVC(X_test, X_train, y_train) :
    clf = SVC()
    clf.fit(X_train, y_train)
    return clf.predict(X_test)

from sklearn.neighbors import KNeighborsClassifier
def ML_KNeighborsClassifier(X_test, X_train, y_train) :
    clf = KNeighborsClassifier()
    clf.fit(X_train, y_train)
    return clf.predict(X_test)

from sklearn.naive_bayes import GaussianNB
def ML_KNeighborsClassifier(X_test, X_train, y_train) :
    clf = GaussianNB()
    clf.fit(X_train, y_train)
    return clf.predict(X_test)

from sklearn.linear_model import SGDClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
def ML_SGDClassifier(X_test, X_train, y_train) :
    clf = make_pipeline(StandardScaler(), SGDClassifier(max_iter=2500, tol=1e-3, penalty = 'elasticnet'))
    clf.fit(X_train, y_train)
    return clf.predict(X_test)

def Algorithm(zip_url):
    response = requests.get(zip_url)

    # Check if the request was successful
    if response.status_code == 200:
        # Read the content of the ZIP archive
        zip_data = BytesIO(response.content)

        # Create a ZipFile object from the fetched data
        with zipfile.ZipFile(zip_data, 'r') as zip_file:
            file_list = zip_file.namelist()

            csv_file_name = next(element for element in file_list if '.data' in element)

            # Check if the CSV file exists in the ZIP archive
            if csv_file_name in file_list:
                # Read the CSV file into a DataFrame
                with zip_file.open(csv_file_name) as csv_file:
                    df = pd.read_csv(csv_file, encoding="ISO-8859-1")

            else:
                print(f"CSV file '{csv_file_name}' not found in the ZIP archive.")
    else:
        print("Failed to fetch the ZIP archive.")



    dff = df
    cmLabel = [ '`'+str(elm) for elm in df[df.columns[-1]].dropna().unique()]


    nrows,ncols = df.shape
    nom = ['N'+str(i) for i in range(ncols)]
    df.columns = nom

    typOfVar = []
    for j in range(ncols):
        for i,elm in df[df.columns[j]].dropna().items():
            if isinstance(elm,str):
                typOfVar.append(j)
                break



    mapping = {}
    for j in typOfVar:
        mapping[df.columns[j]] = {}
        uniq = df[df.columns[j]].dropna().unique()
        for i in range(len(uniq)):
            key = uniq[i]
            mapping[df.columns[j]][key] = i

    for j in typOfVar:
        dff[df.columns[j]] = dff[df.columns[j]].map(mapping[df.columns[j]])




    cols = list(df[df.columns[:-1]].columns)
    X = dff[dff.columns[:-1]].values
    Y = dff[dff.columns[-1]].values


    X_train, X_test, y_train, y_test = train_test_split( X, Y, test_size=0.3, random_state=4)

    dropdown_options_style = {'color': 'white', 'background-color' : 'gray'}
    dropdown_options = [
        {'label': 'All Features', 'value': 'ALL', 'style': dropdown_options_style}
    ]

    for col in range(40):
        dropdown_options.append({'label': 'N'+str(col), 'value': 'N'+str(col), 'style':  dropdown_options_style})


    return  dff,dropdown_options_style,dropdown_options,X_train, y_train,X_test,y_test,cmLabel

zip_url = 'https://archive.ics.uci.edu/static/public/42/glass+identification.zip'
zip_url = 'https://archive.ics.uci.edu/static/public/1/abalone.zip'
zip_url = 'https://archive.ics.uci.edu/static/public/53/iris.zip'
# zip_url = 'https://archive.ics.uci.edu/static/public/19/car+evaluation.zip'
# zip_url = 'https://archive.ics.uci.edu/static/public/15/breast+cancer+wisconsin+original.zip'
# zip_url = 'https://archive.ics.uci.edu/static/public/30/contraceptive+method+choice.zip'
# zip_url = 'https://archive.ics.uci.edu/static/public/2/adult.zip'
# url =  'https://archive.ics.uci.edu/static/public/19/car+evaluation.zip'
dff,dropdown_options_style,dropdown_options,X_train, y_train,X_test,y_test,cmLabel = Algorithm(zip_url)

shw = 0

# Create a dash application Cyborg

app =  dash.Dash(__name__, external_stylesheets=[dbc.themes.DARKLY])
JupyterDash.infer_jupyter_proxy_config()

server = app.server
app.config.suppress_callback_exceptions = True

app.layout = html.Div(
    style={
        'color' : 'black',
        'backgroundColor': 'black',  # Set the background color of the app here
        'height': '100vh'  # Set the height of the app to fill the viewport
    },

   children=[
    html.Br(),
    html.Br(),
    html.H1('Dataset Analysis',
            style={'textAlign': 'center',
                   'color': 'white',
                   'background-color' : 'black',
                   'font-size': 40
                   }),
    html.Br(),
    html.Div(['Link Input Example:',
        html.Br(),
        dcc.Link(zip_url, href=zip_url, target="_blank")],
        style={'textAlign': 'center', 'color': 'white', 'background-color' : 'black',   'font-size': 20}
                ),
    html.Br(),
    html.Div(
        dcc.Input(
            id='input-text',
            inputMode=dropdown_options_style,
            type='text',
            value='',
            placeholder='Enter the link here...',
            style={
                'width':'80%',
                'padding':'3px',
                'font-size': '20px',
                'text-align-last' : 'center',
                'background-color' : 'gray',
                'color': 'black'
            },
        ),
        style={'display': 'flex', 'justify-content': 'center'}  # Center-align the input element
    ),
        # html.Div(id='output-text')
    html.Div(['Analysis of the dataset and evaluation of various classification machine',
              html.Br(),
            'learning algorithms used on data taken from ',
            html.Br(),
           html.Div(id='output-text')],
            # dcc.Link(url, href=url, target="_blank")],
            style={'textAlign': 'center', 'color': 'white', 'background-color' : 'black',   'font-size': 20}),
            html.Br(),
          # Create an outer division
            html.Div([
                html.Div([
                  dcc.Dropdown(
                      id='site-dropdown1',
                      options=dropdown_options,
                      value='ALL',
                      placeholder='Select a feature',
                      style={
                            'width':'80%',
                            'padding':'3px',
                            'font-size': '20px',
                            'text-align-last' : 'center' ,
                            'margin': 'auto' , # Center-align the dropdown horizontally
                            'background' : 'black',
                            'color': 'black',
                            },
                      searchable=True
                  ) ,
                  html.Div(id='output-graph1') ,
                ]),
                html.Div([
                  dcc.Dropdown(
                      id='site-dropdown2',
                      options=[
                              {'label':  'Logistic Regression',          'value': 'LG',   'style':  dropdown_options_style},
                              {'label': 'Decision Tree Classifier',      'value': 'DT',   'style':  dropdown_options_style},
                              {'label': 'K-Nearest Neighbors',           'value': 'KNN',  'style':  dropdown_options_style },
                              {'label': 'Support Vector Classification', 'value': 'SVC',  'style':  dropdown_options_style},
                              {'label': 'Gaussian Naive Bayes',          'value': 'NB',   'style':  dropdown_options_style},
                              {'label': 'Stochastic Gradient Descent',   'value': 'SGD' , 'style':  dropdown_options_style}
                              ],
                      value='LG',
                      placeholder='Select a Machine Learning Classifier',
                      style={
                            'width':'80%',
                            'padding':'3px',
                            'font-size': '20px',
                            'text-align-last' : 'center' ,
                            'margin': 'auto',  # Center-align the dropdown horizontally
                            'background-color' : 'black',
                            'color': 'black'
                            },
                      searchable=True,
                  ) ,
        html.Div([
            html.Div(id='output-graph2', style={'width': '50%', 'display': 'inline-block'}),
            html.Div(id='output-graph3', style={'width': '50%', 'display': 'inline-block'}),
        ]),
        ]),
        ]),
    ]
    )
# Function decorator to specify function input and output
@app.callback(
    [
     Output('output-graph1', 'children'),
     Output('output-graph2', 'children'),
     Output('output-graph3', 'children'),
     Output('output-text', 'children'),
     ],
      [
       Input('site-dropdown1', 'value'),
       Input('site-dropdown2', 'value'),
       Input('input-text', 'value')
       ]
)

def update_graph(feature,ml,txt):

    txt_output = html.Div( [
    dcc.Link(txt, href=txt, target="_blank") ],
    style={'textAlign': 'center', 'color': 'white', 'background-color' : 'black',   'font-size': 20}
            )
    dff,dropdown_options_style,dropdown_options,X_train, y_train,X_test,y_test,cmLabel = Algorithm(txt)
    filtered_df = dff[dff.columns[0:-1]]


    if feature == 'ALL':
        figure1 =  dcc.Graph( figure = plot_history_all_dash(filtered_df ) )
    else:
        figure1 =  dcc.Graph( figure = plot_history_dash(filtered_df,feature) )

    if ml == 'LG' :
        y_pred_LG = ML_LogisticRegression(X_test, X_train, y_train)
        fig2 =   dcc.Graph( figure = plot_confusion_matrix_dash(y_test,y_pred_LG,cmLabel,shw))
        fig3 =   dcc.Graph( figure = plot_classification_report_dash(y_test,y_pred_LG,cmLabel,shw))
    elif ml == 'DT':
        y_pred_DT = ML_DecisionTreeClassifier(X_test, X_train, y_train)
        fig2 =   dcc.Graph( figure = plot_confusion_matrix_dash(y_test,y_pred_DT,cmLabel,shw))
        fig3 =   dcc.Graph( figure = plot_classification_report_dash(y_test,y_pred_DT,cmLabel,shw))
    elif ml == 'KNN':
        y_pred_KNN = ML_KNeighborsClassifier(X_test, X_train, y_train)
        fig2 =   dcc.Graph( figure = plot_confusion_matrix_dash(y_test,y_pred_KNN,cmLabel,shw))
        fig3 =   dcc.Graph( figure = plot_classification_report_dash(y_test,y_pred_KNN,cmLabel,shw))
    elif ml == 'SVC':
        y_pred_SVC = ML_SVC(X_test, X_train, y_train)
        fig2 =   dcc.Graph( figure = plot_confusion_matrix_dash(y_test,y_pred_SVC,cmLabel,shw))
        fig3 =   dcc.Graph( figure = plot_classification_report_dash(y_test,y_pred_SVC,cmLabel,shw))
    elif ml == 'NB':
        y_pred_NB = ML_KNeighborsClassifier(X_test, X_train, y_train)
        fig2 =   dcc.Graph( figure = plot_confusion_matrix_dash(y_test,y_pred_NB,cmLabel,shw))
        fig3 =   dcc.Graph( figure = plot_classification_report_dash(y_test,y_pred_NB,cmLabel,shw))
    elif ml == 'SGD':
        y_pred_SGD = ML_SGDClassifier(X_test, X_train, y_train)
        fig2 =   dcc.Graph( figure = plot_confusion_matrix_dash(y_test,y_pred_SGD,cmLabel,shw))
        fig3 =   dcc.Graph( figure = plot_classification_report_dash(y_test,y_pred_SGD,cmLabel,shw))

    return  [figure1,fig2,fig3,txt_output]

# Run the app
if __name__ == '__main__':
    app.run_server(  host="localhost" , debug=False)
